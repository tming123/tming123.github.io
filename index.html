<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="永远年轻，永远热泪盈眶，相信努力的意义，相信遗憾比失败更可怕。">
<meta property="og:type" content="website">
<meta property="og:title" content="tming&#39;s blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="tming&#39;s blog">
<meta property="og:description" content="永远年轻，永远热泪盈眶，相信努力的意义，相信遗憾比失败更可怕。">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="tming&#39;s blog">
<meta name="twitter:description" content="永远年轻，永远热泪盈眶，相信努力的意义，相信遗憾比失败更可怕。">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.3',
    sidebar: {"position":"right","display":"always","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>tming's blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-right 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">tming's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/10/29/TwoSum/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tming">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="tming's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/29/TwoSum/" itemprop="url">给定一个整型数组和一个target，求数组中两个数的和为target并返回其下标索引</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-10-29T16:06:12+08:00">
                2018-10-29
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Given an array of integers, return indices of the two numbers such that they add up to a specific target.You may assume that each input would have exactly one solution, and you may not use the same element twice.</p>
<p><strong>Example</strong>：Given nums = [2, 7, 11, 15], target = 9,Because nums[0] + nums[1] = 2 + 7 = 9, return [0, 1].</p>
<hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div></pre></td><td class="code"><pre><div class="line">package company.airbnb;</div><div class="line"></div><div class="line">import java.util.Arrays;</div><div class="line">import java.util.HashMap;</div><div class="line">import java.util.Map;</div><div class="line"></div><div class="line">public class AddTwoSum &#123;</div><div class="line">    public static void main(String args[]) &#123;</div><div class="line">        int[] arr = &#123;2, 134, 15, 5, 7, 264, 423, 45, 3, 36&#125;;</div><div class="line">        System.out.println(twoSum3(arr, 18)[0] + &quot;,&quot; + twoSum3(arr, 18)[1]);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 最简单的方法，循环判断，通过了</div><div class="line">    public static int[] twoSum1(int[] nums, int target) &#123;</div><div class="line">        int a = 0;</div><div class="line">        int b = 0;</div><div class="line">        for (int i = 0; i &lt; nums.length - 1; i++)</div><div class="line">            for (int j = i + 1; j &lt; nums.length; j++) &#123;</div><div class="line">                if ((nums[i] + nums[j]) == target) &#123;</div><div class="line">                    a = i;</div><div class="line">                    b = j;</div><div class="line">                    break;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        return new int[]&#123;a, b&#125;;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 采用hash表存储键值对(number[i],i),然后判断target-numbers[i]是否在hash表中</div><div class="line">    public static int[] twoSum2(int[] numbers, int target) &#123;</div><div class="line">        int[] res = new int[2];</div><div class="line">        Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;();</div><div class="line">        for (int i = 0; i &lt; numbers.length; i++) &#123;</div><div class="line">            if (map.containsKey(target - numbers[i])) &#123;</div><div class="line">                res[0] = map.get(target - numbers[i]);</div><div class="line">                res[1] = i;</div><div class="line">                return res;</div><div class="line">            &#125; else &#123;</div><div class="line">                map.put(numbers[i], i);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return res;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 双指针实现</div><div class="line">    public static int[] twoSum3(int[] arr, int sum) &#123;</div><div class="line">        if (arr == null) &#123;</div><div class="line">            return null;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        int low = 0;</div><div class="line">        int high = arr.length - 1;</div><div class="line">        int[] result = &#123;-1, -1&#125;;</div><div class="line"></div><div class="line">        // 先排序</div><div class="line">        Arrays.sort(arr, low, high);</div><div class="line"></div><div class="line">        while (low &lt; high) &#123;</div><div class="line">            if (arr[low] + arr[high] == sum) &#123;</div><div class="line">                if (arr[low] &gt; arr[high]) &#123;</div><div class="line">                    result[0] = high;</div><div class="line">                    result[1] = low;</div><div class="line">                &#125; else &#123;</div><div class="line">                    result[0] = low;</div><div class="line">                    result[1] = high;</div><div class="line">                &#125;</div><div class="line">                break;</div><div class="line">            &#125; else if (arr[low] + arr[high] &gt; sum) &#123;</div><div class="line">                high--;</div><div class="line">            &#125; else &#123;</div><div class="line">                low++;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return result;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/07/数学基础 | 月有阴晴圆缺，此事古难全：概率论/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tming">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="tming's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/07/数学基础 | 月有阴晴圆缺，此事古难全：概率论/" itemprop="url">数学基础 | 月有阴晴圆缺，此事古难全：概率论</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-07T22:06:12+08:00">
                2018-05-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>除了线性代数之外，概率论（probability theory）也是人工智能研究中必备的数学基础。随着连接主义学派的兴起，概率统计已经取代了数理逻辑，成为人工智能研究的主流工具。在数据爆炸式增长和计算力指数化增强的今天，概率论已经在机器学习中扮演了核心角色。</p>
</blockquote>
<p>同线性代数一样，概率论也代表了一种看待世界的方式，其关注的焦点是无处不在的可能性。对随机事件发生的可能性进行规范的数学描述就是概率论的公理化过程。概率的公理化结构体现出的是对概率本质的一种认识。</p>
<p>将同一枚硬币抛掷 10 次，其正面朝上的次数既可能一次没有，也可能全部都是，换算成频率就分别对应着 0% 和 100%。频率本身显然会随机波动，但随着重复试验的次数不断增加，特定事件出现的频率值就会呈现出稳定性，逐渐趋近于某个常数。</p>
<p>从事件发生的频率认识概率的方法被称为“频率学派”（frequentist probability），频率学派口中的“概率”，其实是一个可独立重复的随机实验中单个结果出现频率的极限。因为稳定的频率是统计规律性的体现，因而通过大量的独立重复试验计算频率，并用它来表征事件发生的可能性是一种合理的思路。</p>
<p>在概率的定量计算上，频率学派依赖的基础是古典概率模型。在古典概率模型中，试验的结果只包含有限个基本事件，且每个基本事件发生的可能性相同。如此一来，假设所有基本事件的数目为 n，待观察的随机事件 A 中包含的基本事件数目为 k，则古典概率模型下事件概率的计算公式为<strong>P(A)=kn</strong><br>从这一基本公式就可以推导出复杂的随机事件的概率。</p>
<p>前文中的概率定义针对都是单个随机事件，可如果要刻画两个随机事件之间的关系，这个定义就不够看了。在一场足球比赛中，球队 1:0 取胜和在 0:2 落后的情况下 3:2 翻盘的概率显然是不一样的。这就需要引入条件概率的概念。</p>
<p>条件概率（conditional probability）是根据已有信息对样本空间进行调整后得到的新的概率分布。假定有两个随机事件 A 和 B，条件概率就是指事件 A 在事件 B 已经发生的条件下发生的概率，用以下公式表示<strong>P(A|B)=P(AB)P(B)</strong><br>上式中的 P(AB) 称为联合概率（joint probability），表示的是 A 和 B 两个事件共同发生的概率。如果联合概率等于两个事件各自概率的乘积，即 <strong>P(AB)=P(A)⋅P(B)</strong>，说明这两个事件的发生互不影响，即两者相互独立。对于相互独立的事件，条件概率就是自身的概率，即 <strong>P(A|B)=P(A)</strong>。</p>
<p>基于条件概率可以得出全概率公式（law of total probability）。全概率公式的作用在于将复杂事件的概率求解转化为在不同情况下发生的简单事件的概率求和，全概率公式代表了频率学派解决概率问题的思路，即先做出一些假设（P(Bi)），再在这些假设下讨论随机事件的概率（P(A|Bi)）。对全概率公式稍作整理，就演化出了求解“逆概率”这一重要问题。所谓“逆概率”解决的是在事件结果已经确定的条件下（P(A)），推断各种假设发生的可能性（P(Bi|A)）。由于这套理论首先由英国牧师托马斯·贝叶斯提出，因而其通用的公式形式被称为贝叶斯公式：</p>
<p><strong>P(Bi|A)=P(A|Bi)⋅P(Bi)∑Nj=1P(A|Bj)⋅P(Bj)</strong></p>
<p>贝叶斯公式可以进一步抽象为贝叶斯定理（Bayes’ theorem）：</p>
<p><strong>P(H|D)=P(D|H)⋅P(H)P(D)</strong></p>
<p>式中的 P(H) 被称为先验概率（prior probability），即预先设定的假设成立的概率；P(D|H) 被称为似然概率（likelihood function），是在假设成立的前提下观测到结果的概率；P(H|D) 被称为后验概率（posterior probability），即在观测到结果的前提下假设成立的概率。</p>
<p>从科学研究的方法论来看，贝叶斯定理提供了一种全新的逻辑。它根据观测结果寻找合理的假设，或者说根据观测数据寻找最佳的理论解释，其关注的焦点在于后验概率。概率论的贝叶斯学派（Bayesian probability）正是诞生于这种理念。</p>
<p>在贝叶斯学派眼中，概率描述的是随机事件的可信程度。如果手机里的天气预报应用给出明天下雨的概率是 85%，这就不能从频率的角度来解释了，而是意味着明天下雨这个事件的可信度是 85%。</p>
<p>频率学派认为假设是客观存在且不会改变的，即存在固定的先验分布，只是作为观察者的我们无从知晓。因而在计算具体事件的概率时，要先确定概率分布的类型和参数，以此为基础进行概率推演。</p>
<p>相比之下，贝叶斯学派则认为固定的先验分布是不存在的，参数本身也是随机数。换言之，假设本身取决于观察结果，是不确定并且可以修正的。数据的作用就是对假设做出不断的修正，使观察者对概率的主观认识更加接近客观实际。</p>
<p>概率论是线性代数之外，人工智能的另一个理论基础，多数机器学习模型采用的都是基于概率论的方法。但由于实际任务中可供使用的训练数据有限，因而需要对概率分布的参数进行估计，这也是机器学习的核心任务。</p>
<p>概率的估计有两种方法：最大似然估计法（maximum likelihood estimation）和最大后验概率法（maximum a posteriori estimation），两者分别体现出频率学派和贝叶斯学派对概率的理解方式。</p>
<p>最大似然估计法的思想是使训练数据出现的概率最大化，依此确定概率分布中的未知参数，估计出的概率分布也就最符合训练数据的分布。最大后验概率法的思想则是根据训练数据和已知的其他条件，使未知参数出现的可能性最大化，并选取最可能的未知参数取值作为估计值。在估计参数时，最大似然估计法只需要使用训练数据，最大后验概率法除了数据外还需要额外的信息，就是贝叶斯公式中的先验概率。</p>
<p>从理论的角度来说，频率学派和贝叶斯学派各有千秋，都发挥着不可替代的作用。但具体到人工智能这一应用领域，基于贝叶斯定理的各种方法与人类的认知机制吻合度更高，在机器学习等领域中也扮演着更加重要的角色。</p>
<p>概率论的一个重要应用是描述随机变量（random variable）。根据取值空间的不同，随机变量可以分成两类：离散型随机变量（discrete random variable）和连续型随机变量（continuous random variable）。在实际应用中，需要对随机变量的每个可能取值的概率进行描述。</p>
<p>离散变量的每个可能的取值都具有大于 0 的概率，取值和概率之间一一对应的关系就是离散型随机变量的分布律，也叫概率质量函数（probability mass function）。概率质量函数在连续型随机变量上的对应就是概率密度函数（probability density function）。</p>
<p>需要说明的是，概率密度函数体现的并非连续型随机变量的真实概率，而是不同取值可能性之间的相对关系。对连续型随机变量来说，其可能取值的数目为不可列无限个，当归一化的概率被分配到这无限个点上时，每个点的概率都是个无穷小量，取极限的话就等于零。而概率密度函数的作用就是对这些无穷小量加以区分。虽然在 x→∞ 时，1/x 和 2/x 都是无穷小量，但后者永远是前者的 2 倍。这类相对意义而非绝对意义上的差别就可以被概率密度函数所刻画。对概率密度函数进行积分，得到的才是连续型随机变量的取值落在某个区间内的概率。</p>
<p>定义了概率质量函数与概率密度函数后，就可以给出一些重要分布的特性。重要的离散分布包括两点分布、二项分布和泊松分布，重要的连续分布则包括均匀分布、指数分布和正态分布。</p>
<p>除了概率质量函数 / 概率密度函数之外，另一类描述随机变量的参数是其数字特征。数字特征是用于刻画随机变量某些特性的常数，包括数学期望（expected value）、方差（variance）和协方差（covariance）。</p>
<p>数学期望即均值，体现的是随机变量可能取值的加权平均，即根据每个取值出现的概率描述作为一个整体的随机变量的规律。方差表示的则是随机变量的取值与其数学期望的偏离程度。方差较小意味着随机变量的取值集中在数学期望附近，方差较大则意味着随机变量的取值比较分散。</p>
<p>数学期望和方差描述的都是单个随机变量的数字特征，如果要描述两个随机变量之间的相互关系，就需要用到协方差和相关系数。协方差度量了两个随机变量之间的线性相关性，即变量 Y 能否表示成以另一个变量 X 为自变量的 aX+b 的形式。</p>
<p>根据协方差可以进一步求出相关系数（correlation coefficient），相关系数是一个绝对值不大于 1 的常数，它等于 1 意味着两个随机变量满足完全正相关，等于 -1 意味着两者满足完全负相关，等于 0 则意味着两者不相关。需要说明的是，无论是协方差还是相关系数，刻画的都是线性相关的关系。如果随机变量之间的关系满足 Y=X2，这样的非线性相关性就超出了协方差的表达能力。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/06/数学基础 | 九层之台，起于累土：线性代数/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tming">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="tming's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/06/数学基础 | 九层之台，起于累土：线性代数/" itemprop="url">数学基础 | 九层之台，起于累土：线性代数</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-06T22:06:12+08:00">
                2018-05-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>“人工智能”的基础与数学紧密相关。必备的数学知识是理解人工智能不可或缺的要素，今天的种种人工智能技术归根到底都建立在数学模型之上，而这些数学模型又都离不开线性代数（linear algebra）的理论框架。</p>
</blockquote>
<p>事实上，线性代数不仅仅是人工智能的基础，更是现代数学和以现代数学作为主要分析方法的众多学科的基础。从量子力学到图像处理都离不开向量和矩阵的使用。而在向量和矩阵背后，线性代数的核心意义在于提供了⼀种看待世界的抽象视角：万事万物都可以被抽象成某些特征的组合，并在由预置规则定义的框架之下以静态和动态的方式加以观察。</p>
<p>线性代数中最基本的概念是集合（set）。在数学上，集合的定义是由某些特定对象汇总而成的集体。集合中的元素通常会具有某些共性，因而可以用这些共性来表示。对于集合 { 苹果，橘子，梨 } 来说， 所有元素的共性是它们都是水果；对于集合 {牛，马，羊} 来说，所有元素的共性是它们都是动物。当然 { 苹果，牛 } 也可以构成一个集合，但这两个元素并没有明显的共性，这样的集合在解决实际问题中的作用也就相当有限。</p>
<p>“苹果”或是“牛”这样的具体概念显然超出了数学的处理范围，因而集合的元素需要进行进一步的抽象——用数字或符号来表示。如此一来，集合的元素既可以是单个的数字或符号，也可以是多个数字或符号以某种方式排列形成的组合。</p>
<p>在线性代数中，由单独的数 a 构成的元素被称为标量（scalar）：一个标量 a 可以是整数、实数或复数。如果多个标量 a1,a2,⋯,an 按一定顺序组成一个序列，这样的元素就被称为向量（vector）。显然，向量可以看作标量的扩展。原始的一个数被替代为一组数，从而带来了维度的增加，给定表示索引的下标才能唯一地确定向量中的元素。</p>
<p>每个向量都由若干标量构成，如果将向量的所有标量都替换成相同规格的向量，得到的就是矩阵（matrix），相对于向量，矩阵同样代表了维度的增加，矩阵中的每个元素需要使用两个索引（而非一个）确定。同理，如果将矩阵中的每个标量元素再替换为向量的话，得到的就是张量（tensor）。直观地理解，张量就是高阶的矩阵。</p>
<p>如果把三阶魔方的每一个小方块看作一个数，它就是个 3×3×3 的张量，3×3 的矩阵则恰是这个魔方的一个面，也就是张量的一个切片。相比于向量和矩阵，张量是更加复杂，直观性也更差的概念。</p>
<p>向量和矩阵不只是理论上的分析工具，也是计算机工作的基础条件。人类能够感知连续变化的大千世界，可计算机只能处理离散取值的二进制信息，因而来自模拟世界的信号必须在定义域和值域上同时进行数字化，才能被计算机存储和处理。从这个角度看，线性代数是用虚拟数字世界表示真实物理世界的工具。</p>
<p>在计算机存储中，标量占据的是零维数组；向量占据的是一维数组，例如语音信号；矩阵占据的是二维数组，例如灰度图像；张量占据的是三维乃至更高维度的数组，例如 RGB 图像和视频。</p>
<p>描述作为数学对象的向量需要有特定的数学语言，范数和内积就是代表。范数（norm）是对单个向量大小的度量，描述的是向量自身的性质，其作用是将向量映射为一个非负的数值。范数计算的是单个向量的尺度，内积（inner product）计算的则是两个向量之间的关系。两个相同维数向量内积的表达式为⟨x,y⟩=∑ixi⋅yi，即对应元素乘积的求和。内积能够表示两个向量之间的相对位置，即向量之间的夹角。一种特殊的情况是内积为 0，即 ⟨x,y⟩=0。在二维空间上，这意味着两个向量的夹角为 90 度，即相互垂直。而在高维空间上，这种关系被称为正交（orthogonality）。如果两个向量正交，说明他们线性无关，相互独立，互不影响。</p>
<p>在实际问题中，向量的意义不仅是某些数字的组合，更可能是某些对象或某些行为的特征。范数和内积能够处理这些表示特征的数学模型，进而提取出原始对象或原始行为中的隐含关系。</p>
<p>如果有一个集合，它的元素都是具有相同维数的向量（可以是有限个或无限个）， 并且定义了加法和数乘等结构化的运算，这样的集合就被称为线性空间（linear space），定义了内积运算的线性空间则被称为内积空间（inner product space）。在线性空间中，任意一个向量代表的都是 n 维空间中的一个点；反过来， 空间中的任意点也都可以唯一地用一个向量表示。两者相互等效。</p>
<p>在线性空间上点和向量的相互映射中，一个关键问题是参考系的选取。在现实生活中，只要给定经度、纬度和海拔高度，就可以唯一地确定地球上的任何一个位置，因而经度值、纬度值、高度值构成的三维向量 (x, y, h) 就对应了三维物理空间中的⼀个点。</p>
<p>可是在直觉无法感受的高维空间中，坐标系的定义可就没有这么直观了。要知道，人工神经网络要处理的通常是数以万计的特征，对应着维度同样数以万计的复杂空间，这时就需要正交基的概念了。</p>
<p>在内积空间中，一组两两正交的向量构成这个空间的正交基（orthogonal basis），假若正交基中基向量的 L2 范数都是单位长度 1，这组正交基就是标准正交基（orthonormal basis）。正交基的作用就是给内积空间定义出经纬度。⼀旦描述内积空间的正交基确定了，向量和点之间的对应关系也就随之确定。</p>
<p>值得注意的是，描述内积空间的正交基并不唯一。对二维空间来说，平面直角坐标系和极坐标系就对应了两组不同的正交基，也代表了两种实用的描述方式。</p>
<p>线性空间的一个重要特征是能够承载变化。当作为参考系的标准正交基确定后，空间中的点就可以用向量表示。当这个点从一个位置移动到另一个位置时，描述它的向量也会发生改变。点的变化对应着向量的线性变换（linear transformation），而描述对象变化抑或向量变换的数学语言，正是矩阵。</p>
<p>在线性空间中，变化的实现有两种方式：一是点本身的变化，二是参考系的变化。在第一种方式中，使某个点发生变化的方法是用代表变化的矩阵乘以代表对象的向量。可是反过来，如果保持点不变，而是换一种观察的角度，得到的也将是不同的结果，正所谓“横看成岭侧成峰，远近高低各不同”。</p>
<p>在这种情况下，矩阵的作用就是对正交基进行变换。因此，对于矩阵和向量的相乘，就存在不同的解读方式：</p>
<p>Ax=y</p>
<p>这个表达式既可以理解为向量 x 经过矩阵 A 所描述的变换，变成了向量 y；也可以理解为一个对象在坐标系 A 的度量下得到的结果为向量 x，在标准坐标系 I（单位矩阵：主对角线元素为 1，其余元素为 0）的度量下得到的结果为向量 y。</p>
<p>这表示矩阵不仅能够描述变化，也可以描述参考系本身。引用网络上一个精当的类比：表达式 Ax 就相当于对向量 x 做了一个环境声明，用于度量它的参考系是 A。如果想用其他的参考系做度量的话，就要重新声明。而对坐标系施加变换的方法，就是让表示原始坐标系的矩阵与表示变换的矩阵相乘。</p>
<p>描述矩阵的⼀对重要参数是特征值（eigenvalue）和特征向量（eigenvector）。对于给定的矩阵 A，假设其特征值为λ，特征向量为 x，则它们之间的关系如下：</p>
<p>Ax=λx</p>
<p>正如前文所述，矩阵代表了向量的变换，其效果通常是对原始向量同时施加方向变化和尺度变化。可对于有些特殊的向量，矩阵的作用只有尺度变化而没有方向变化，也就是只有伸缩的效果而没有旋转的效果。对于给定的矩阵来说，这类特殊的向量就是矩阵的特征向量，特征向量的尺度变化系数就是特征值。</p>
<p>矩阵特征值和特征向量的动态意义在于表示了变化的速度和方向。如果把矩阵所代表的变化看作奔跑的人，那么矩阵的特征值就代表了他奔跑的速度，特征向量代表了他奔跑的方向。但矩阵可不是普通人，它是三头六臂的哪吒，他的不同分身以不同速度（特征值）在不同方向（特征向量）上奔跑，所有分身的运动叠加在⼀起才是矩阵的效果。</p>
<p>求解给定矩阵的特征值和特征向量的过程叫做特征值分解，但能够进行特征值分解的矩阵必须是 n 维方阵。将特征值分解算法推广到所有矩阵之上，就是更加通用的奇异值分解。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/05/来自《22岁年薪150万》作者Denny的一封信 /">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tming">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="tming's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/05/来自《22岁年薪150万》作者Denny的一封信 /" itemprop="url">来自《22岁年薪150万》作者Denny的一封信</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-05T17:35:12+08:00">
                2018-05-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>很久很久以前，在大叔还没有成为一个大叔的时候，他曾经写过一篇1.7万字的文章。它最早的题目叫做《给明年依然年轻的我们》。</p>
<p>不过，你看到过的版本很可能叫《22岁年薪150万…》或者《华为boss力荐公司高层看的一篇文章，真的很经典!!! 》或者是其它更有中国特色的标题。</p>
<p>这些都不重要。因为这是一篇好文字。</p>
<p>你给它起名叫《一篇普通的文字》，它依然是一篇好文字。如果标题党能让更多人接触到这篇文字，那标题党就是件好事。想到这里，我也就不怎么困扰了。</p>
<p>离我写这篇在网上被大几百万人读过的长文章，已经过去了若干个年头（反正大叔是记不得了）。大叔经历了大起大伏，也目睹了一些悲欢离合。有人问我说，这段岁月里，你有哪些写在文章里的想法改变了的吗？于是我又把它读了一遍。</p>
<p>它把我带回到自己开始的那一天。从那天以后的这段岁月里，我以2-3倍的速度活着、做事、跌倒、爬起来、体验这个世界，积累了许多对于这1.7万字里未提及的生活话题和工作话题的心得和经验。其中能写的，我也尽我所能的写成了实用型的文章，你都能在我的博客里找到；还有很多很有意思但暂时不便写的商战经验，想必有一天我也会写出来。</p>
<p>只是再读这篇文章中讨论的那些话题——欲望、外界、标签、天才、时间、人生目标、经历——我依旧有不变的感觉。我想在沧海桑田中，这已经是最大的进步。</p>
<p>如果你的问题是，“如何知道自己究竟想要什么？” 或者 “如何找到人生目标？” 或许你能在这些文字里找到答案。</p>
<p>如果很多年前，你用了文中的方法，依然找不到答案，建议你再找个安静的时间，尝试一次。如果依然无果，那也没关系，你只是需要更多的经历。</p>
<p>这是我在无数次被奇奇怪怪地盗版转载后，第一次自己发这篇文字。也可能是第一篇无广告完整版。如果它在你人生的某个时刻曾经为你带来帮助，那请让更多人看到。</p>
<p>至少对我来说，这篇文字就像你起程离开港湾时的那个灯塔，在你回首探望过去时，提醒着你勿忘初心。</p>
<p>也祝你好运。</p>
</blockquote>
<p>以下是无广告完整版正文</p>
<hr>
<p>今天是22岁的最后一天。几个月前，我从沃顿商学院毕业，用文凭上“最高荣誉毕业”的标签安抚了已经年过半百的老妈，然后转头辞去了毕业后的第一份工作，跟一家很受尊敬的公司、还有150万的年薪道了别，回到了上海，加入了“刚毕业就失业”俱乐部，开始了一天三顿盒饭的新生活，开始创建一个叫做连客的小东西。中间许多精彩剧情暂时略过。</p>
<p>我肯定不是第一个做过这样事的人，也肯定不会是最后一个。所以在说自己的一些有趣故事前，我想借用大家（包括30岁甚至40岁以上的朋友）的一点时间和一点平和的心态，和大家分享过去一年以来一直没说的一些话。所以前两部说的是对于一些一直困扰着我们的关键词的理解和体会。他们是：欲望、外界、标签、天才、时间、经历、人生目标、后悔、和现实。</p>
<p>这可能会是一篇科普文，也可能会是一篇长篇小说，但我不想这篇文章变成一篇励志文，大家都审美疲劳了。所以我想忽略阳春白雪，尽管信息量很大，但是至少说一些实实在在的经验和故事，说一些效果立竿见影的观点，再说说活捉林志玲什么的，总之让大家多看一点就多获得一点实际的价值。</p>
<h3 id="第一部：那些最容易被理解错误的事"><a href="#第一部：那些最容易被理解错误的事" class="headerlink" title="第一部：那些最容易被理解错误的事"></a>第一部：那些最容易被理解错误的事</h3><p><strong>关于欲望</strong></p>
<p>这些是我们内心里和人生理想一样真实的东西：学历、工作、房、车、财富、以及爱。我们每个人都愿意为了这些欲望去付出，无论付出的是汗水、鲜血、还是身体健康、又或是其它你懂的。尽管我们付出的方式可能不被社会主流认同、可能没那么具有有戏剧性，但你和我、北大图书馆里的学生和网吧中奋斗的少年、职场杜拉拉和夜场里跳舞的小姐、韩寒和芙蓉凤姐（韩少躺着也中枪-_-），我们谁没有为了一个目标连续熬夜奋斗过呢？我们谁没有为了得到一样东西而撕心裂肺地付出过呢？谁没有过那种拼命得快受不了的感觉呢？所以我们最不缺励志的故事，因为我们每个人都是付出领域的专家。</p>
<p>真正的问题是，当我们跑得越快，越是无法考虑我们是否在朝着正确的方向奔跑。</p>
<p>北野武讲过一个很有趣的故事。他说他没出名之前想有一天有了钱，一定要开跑车，吃高档餐厅，跟女人们睡觉。而真正功成名就的时候，他发现开保时捷的感觉并没有那么好，因为“看不到自己开保时捷的样子”。结果他就让朋友开，自己打个出租车，在后面跟着，还对出租司机说：看，那是我的车。</p>
<p>我想说，过去几年里我认识的、深交的、共事过的所有人，包括身边一批又一批二十出头收入一百多万的金融朋友、三十岁左右收入几百万的前辈朋友、以及简历金碧辉煌得已经不在乎收入的大BOSS、以及我自己的经历告诉我两件事：</p>
<p>一，顶级学校的文凭、顶级公司的工作、顶级的收入、顶级的房、顶级的车、顶级的声望，这些都无法满足人类。</p>
<p>二，无论是通过爸妈，通过运气，还是通过奋斗得到这些顶级的东西，人类都不会得到更多的幸福感。</p>
<p>接着北野武的故事说下去。想象一下：你今天骑在一辆助动车上，一个小山村来的年轻人经过，说你的车好帅，你不会有任何的满足感。十几年的奋斗后，你坐在一辆你今天都叫不出型号的保时捷的驾驶位上，一个路人经过，说你的车好帅，相信我，你也不会有任何的满足感。你不在乎他，就像你今天不在说你助动车帅的人。你的视角在变。每当我们考虑许多年后能够取得的成就，我们总是习惯站在今天的角度去衡量幸福感和满足感。你今天的视角只是错觉，却让你相信自己的目标是正确的。这是我们最容易跑错方向的时候。</p>
<p>人类的需求是很奇特的。我们吃第一个面包的时候的幸福感，和我们吃第一千个面包的时候的幸福感，是差不多的，前者甚至比后者还多一些。同样的感觉适用于我们赚到的第一笔一万元和第一笔一千万元，第一辆十万的车和第一辆一千万的车，第一个女孩和第十个女人，第一个男生和第十个男人。“生理需求、安全需求、归属与爱的需求、尊重的需求和自我实现的需求”–在著名的马斯洛五大需求中，你从任意一个细分需求里获得的幸福感只能有那么多。</p>
<p>我们清楚地知道快感和幸福感的不同，我们也知道欲望和需求是两个东西（你从来没有听说过“马斯洛五大欲望”对不对？），但是我们的不幸福却是因为不小心把快感当成了幸福感，把欲望当成了需求，而这就是因为我们常站在现在的视角去想象未来的感受。事实是，就好像我们不需要很多的面包一样，我们不需要很多的财富，不需要很多的爱。因为他们很难给你带来更多快乐。当然，我们也不需要去拔高理想和自由的重要性。你可以尝试着停下来思考一下，这五种需求是否真的有高低之分，思考一下，是否连最贫穷最饥饿的人们，都一直在生活中同时追求着这五个高低层次的需求。你会发现其实这五种需求一样真实，离你一样近，也一样远。然后你需要找到一个可以同时实现这五种需求的平衡点。这个平衡点就是只属于你的奔跑方向。这篇文章会实实在在地帮你找到这个方向。但在这之前，我们先谈一些别的。</p>
<p><strong>关于外界</strong></p>
<p>外界带给我们生活最大的影响是嫉妒和比较。</p>
<p>我们一直高估了嫉妒。举个例子，没有人嫉妒雷帝Gaga。雷帝Gaga应该要比我们都更有名、更有钱、坐更好的车、住更大的房子，比我们更随心所欲，而且也比我们更有才华。但你不嫉妒她，对么？我们没有人嫉妒雷帝Gaga–因为她实在是太雷了。她奇怪得让我们完全不能把我们自己跟她联系在一起，所以我们在名利和才华面前没有自卑，也没有嫉妒，更没有仇恨。反而，我们会去思考，觉得她挺有趣的，挺发人深省的，不是么？</p>
<p>所以当你见到好事情发生在了那个他或者那个她身上，嫉妒的小火苗在你心中扑哧扑哧的时候，不如把TA当成那个很奇怪的雷帝Gaga吧。因为这样的时候，我们就会懂得抛开个人的杂念，去真正思考别人的亮点。</p>
<p>至于比较（Social Comparison），我们可以选择努力向那个绩点4.0的同学看齐，努力向那个年薪几十万的旧识看齐，努力向那个不断得到提拔的同事看齐。或者，我们也可以选择看看外面更大的世界，那些和我们一样年轻的人们。看上去像是有30岁阅历的阿呆Adele，19岁时出了张白金专辑《19》，21岁时出了全销量1200万张的专辑《21》，拿了两座格莱美。她出生于1988年。眼神和心态似乎已经像中年人那样淡定的杜兰特和德里克罗斯，两个毫无疑问的超级球星，他们也出生于1988年。如果你喜欢实用一点的，那么iPhone上用户量最大的个人开发第三方浏览器猛犸浏览器的开发者，是一个1992年出生的北京少年。如果你的视线中有一个世界舞台，那么你会看到上面的人物已经越来越接近你的年龄。</p>
<p>我们不需要去看齐，我们只需要去“看”。去看到这个世界除了你现在正处在的那个若干平米的封闭空间以外，还有许多许多精彩的事正在发生。当你发现这个世界的深度和广度，你就会发现你跟你身边的那些“同类人”根本没什么好比的。这个世界太大了。你不是你自己的标杆，别人也不是。谁都不是你的标杆，这是一个没有标杆的时代。</p>
<p>我们要做的是试着不去嫉妒，不去比较，更不要批判，但要试着去观察、去倾听，然后去思考、去沉淀、去让所有外界的信息在你大脑里经历一个长时间的处理过程。在你的大脑还没有沉淀出你自己对一件事的观点前，不要发表观点，不要给出你的定论。我们可以不断在大脑中质疑我们所看到的、听到的，我们可以不断挑战自己的想法、挑战任何理所当然的存在，只要我们保证我们的大脑一直在思考，独立地思考。要记得，你和世界上所有人都不一样。</p>
<p><strong>关于标签</strong></p>
<p>“牛逼”是过去几年里笔者听到的比较多的一个形容词。当我们喜欢的人称赞我们的时候，我们总是P颠P颠的。在这里为自己开脱一下，觉得这挺好，说明活得挺真实。</p>
<p>但笔者想用一个很好的朋友（自己来认领）去年当着我面描述我听的原话，来翻译一下这个已经被用得和“帅哥”“美女”一样烂俗的词。她说，“你想太多了（这是她一贯的开场白）。你只是有很多很牛的标签–上海中学、沃顿商学院、最高荣誉、黑石的全职Offer、百万年薪。至于你本身么，牛不牛就说不清楚了。”</p>
<p>这个故事告诉我们：一、“牛”和“帅哥”“美女”一样，是一种打招呼的方式，二、“牛”的从来都是那些标签，那些改变了金融产业的企业，那些通过培养人才改变了世界的学校，那些定义了时尚的品牌。虽然我无意改变大家打招呼的方式，但对于还没奔到三的人类来说，“高档”“精英”“牛逼”其实不如“做得不错”或者“挺有意思的”来得更实在。当然，等奔到了三，我们就更不想用这些词了。</p>
<p>如果你曾经或者将来获得了任何标签，不管是高盛中金麦肯锡，还是北大清华常春藤，又或是Gucci Prada Armani，有两件事值得思考一下。</p>
<p>第一件事用来提醒自己：撕去这些标签，我们或许还未能为500强的客户们创造等同于我们年薪的价值，我们或许还未能用知识改变世界，我们或许还未能把那件衣服穿出五位数价格的范儿。</p>
<p>第二件事用来看清自己：这的确是一个人人都用标签来识别对方的社会，但是我们要记住我们的价值和我们身上的标签没有半毛钱关系。成功不是你有什么标签，而是你用这些标签做了什么。(是的，文章开头的“沃顿商学院”“150万”“最高荣誉毕业”这些个标签让一部分人把这篇文章看到了现在，但无论如何，对于心理上被冒犯到了的人，在此致以诚恳的歉意）。</p>
<p>总之，把标签用在正确的地方，创造一些价值，虽然不是大到改变世界，也至少带来一些存在的意义。就不展开来说了。</p>
<p><strong>关于天才</strong></p>
<p>不要去考虑什么天赋异禀，一切都来自经历和渴望。特别是这些年，当我认识了一些全中国、甚至全美国最“天才”的年轻人以后，才发现哪有什么天才，如果把他们的经历一个个说出来，大家肯定觉得完全就是一群苦逼啊。但这些苦逼有一个共同点，他们很清楚的知道自己究竟需要什么，并且很嗨地追求着。</p>
<h3 id="第二部：那些最重要的事"><a href="#第二部：那些最重要的事" class="headerlink" title="第二部：那些最重要的事"></a>第二部：那些最重要的事</h3><p><strong>关于时间</strong></p>
<p>时间是唯一的货币。你所拥有的财富很重要，因为你可以用它用来换很多东西。你所拥有的时间远远更重要，因为你可以用时间来换这世界上的任何东西，包括财富，包括成就感，包括幸福感，包括其他那些我们都清楚的、比财富更让我们的生命有价值的东西。是的，每个人拿时间换每样东西的汇率都不同，有些人可以用很少的时间换到很多的财富，有些人需要用很多的时间换到很少的幸福。但是事实是，只要你愿意花时间，你可以换到任何东西。所以你要想清楚，你到底要用时间来换取这世上无限可能中的哪些。打开你的视野，你会发现有太多经历和体验可以让你去换取。但你的时间银行里每天只存了24个小时。你可能以为你还有一辈子的时间去做一些你想做的事，但事实是，没有人可以保证明天上帝是否会往你的银行里存另一个24小时。所以，你要想清楚。</p>
<p><strong>关于经历</strong></p>
<p>如果你今天能从这篇文章中带走任何一样东西，我希望会是接下来关于经历的这一段。</p>
<p>经历的英文叫什么？如果你曾经玩过角色扮演类游戏（RPG），你会知道有一个概念叫EXP，全称叫Experience，这就是经历的英文。人生就是一场巨大的RPG，你扮演你自己。你唯一升级的方法，就是不断地积累EXP。</p>
<p>我们都了解那些故事，我们都懂那些道理，看了那么多励志贴，我们甚至都快知道为什么乔布斯会成为乔布斯。但只有经历才能让我们真正把那些道理变成意识。那些改变我们一生的道理，都是不是别人教会的。</p>
<p>所以即使你有最完美的理论，你都没有把握说服那些还没有开上保时捷的人们，让他们懂得保时捷不是他们想要的，也没有把握去说服那些还没有在投行工作过的孩子，让他们懂得去放弃投行（更何况，对于那些热爱金融的孩子来说，你的劝诫极有可能是错的）。所以哪怕这篇文章非常努力地想要往实用的方向靠拢，可能你看完以后还是没有任何领悟。这一切就像你无法说服还没有吃过很多很多面包的人们，让他们懂得吃一千个面包是要反胃的。</p>
<p>在人生的每个阶段，只有我们已经拥有的那些经历，决定了我们下一步会做什么。所以很多时候，你只要记得一件事，那就是: 去体验不同的经历。去爱，去恨，去在热恋中没心没肺地笑，去在失恋后声嘶力竭地哭，去翘课，去打架，去拼了命的读书，去让自己真的领悟那些道理。你所尝试的事，你所认识的人，都是你经历的一部分。他们帮助你去理解你一直知道但是不曾真正理解的事，他们帮助你去看到一直存在着但是你不曾看到的世界。</p>
<p>但是，你的人生很短，你的时间货币只有那么多。所以除了乔布斯已经告诉你的“不要生活在别人的世界里”你还要记得，永远不要重复一样的经历，因为你不会从第二次一样的经历中收获到更多，更因为这个庞大的世界有太多有趣的人等待着我们去认识、太多截然不同的经历等待着我们去体验。</p>
<p>这篇文章也会实实在在地帮助你探索不同的经历。你只要记住，如果你每个星期都在做着差不多的事情，那么一年以后你还是一年前的你，只是老了一岁。如果你愿意每个星期、或者每个月都去尝试一种新的体验，或者认识一个来自完全不同背景的朋友，那么一年后你和一年前一样年轻，只是比别人多活了一年，多了一年的阅历和对世界的认知。</p>
<p><strong>关于是否会为了去经历、去追随感情和理想而后悔</strong></p>
<p>我们一定会后悔。但我们不会为了作出追随感情、或者追随理想的决定而后悔。事实是，如果我们有努力追寻、不愿放弃的梦想、如果我们有深爱的、不想伤害的人，那么在这条道路上，我们必然会为我们曾经做过的某些事而后悔。当我们离理想和真爱越是近，我们越是容易后悔。就好像晚了一分钟错过飞机的人会比晚了一个小时错过飞机的人更后悔懊恼–因为我们会清楚地看到如果自己不曾犯下某些错误，如果我们再多那么一点点的坚持，就或许已经实现了理想。所以后悔其实是一个信号，它告诉我们，离目标已经很近了。更重要的是，我们活着不是为了追求什么瞎扯的“无悔的生活”，我们不用为那些后悔而伤心痛苦。因为在我们选择的这条道路上，后悔不是告诉我们曾经做错了，而是告诉我们怎样可以做得更好。</p>
<p><strong>关于如何找到人生目标</strong></p>
<p>兑现承诺的时候到了。我想用一种最简单、直接、有成效方法来解决那些励志文章和成功故事的一个通病：就是他们一直鼓励我们“做我们想做的事”，但从来不告诉年轻迷茫的我们怎么去找到“我们想做的事”（以至于误导了很多朋友以为那就是“我想一觉睡到国庆节”或者“我想做个吃货”之类的意思）。</p>
<p>我要说的这个方法在我认识的许多人身上成功过，但它不是我想出来的。知名博客写手Steve Pavlina在它的博客中对这个方法有很详细的描述，但似乎也不是Steve Pavlina自己想出来的。网上也有不少中文翻译版本，有可能你曾经看到过，但那些翻译都有失偏颇，以至于让读者很难理解精髓。所以在这里把原文重新编辑，结合以上的经验分享，再用比较适合中国人的陈述方式分享给大家。如果你愿意尝试，愿意按照要求去做，或许我们可以用接下来的不到500个字，帮助你在20分钟到1个小时内找到你的人生目标。</p>
<p>我们开始吧。</p>
<p>(1) 先在你忙碌的生活中找出一个小时的完全空闲的时间。关掉手机，关掉电脑，关上房门，保证这一个小时没有任何打扰。这一小时只属于你，和你要找到人生理想这件事。你要记住，这可能是你人生最重要的一个小时。你的生命可能在这一个小时候变得不同。如果一个小时的时间货币只能用来换一样东西，那么就是找到你的人生目标绝对是最值得的。</p>
<p>(2) 准备几张大的白纸，和一支笔。</p>
<p>(3) 在第一张白纸上的最上方中央，写下一句话：“你这辈子活着是为了什么？”</p>
<p>(4) 是的，接下来你要做的，就是回答这个问题。把你脑中闪过的第一个想法马上写在第一行。任何想法都可以，而且可以只是几个字。比如说：“赚很多钱。”</p>
<p>(5) 不断地重复第4步。直到你哭出来为止。</p>
<p>是的，就是这么简单。尽管这个方法看上去很傻，但是它很有效。如果你想要找到人生目标，你就必须先剔除脑中所有那些“伪装的答案”。你通常需要15-20分钟的时间和过程去剔除那些覆盖在表面上的那些受到外界观念、主流思维影响而得出的答案。所有的这些伪装的答案都来自于你的大脑、你的思维、和你的回忆，但真正的答案出现时，你会感觉到它来自你的内心最深处。</p>
<p>对于从来没有考虑过这类问题的人来说，可能会需要比较长的时间（一个小时或者更多）才能把脑子里面的那些杂物剔除掉。在你写到50-100条的时候，你可能会想放弃，或者找个借口去做别的事。因为你可能觉得这个方法没有任何效果，你的答案很杂乱，你也完全没有想哭的感觉。这很正常。不要放弃，坚持想和写下去，这个抵触的感觉会慢慢地过去的。记住，你坚持下去的决定会将这一个小时变成你人生最重要的一个小时。</p>
<p>当你写到第100个或者第200个答案的时候，你可能突然会有一阵内心情感上的涌动，但还不至于让你哭出来。这 说明那还不是最终的答案。但是把这些答案圈起来，在你接下来的写的过程中你可以回顾这些答案，帮助你找到最终的答案，因为那可能会是几个答案的排列组合。但无论如何，最终的答案一定会让你流泪，让你情感上崩溃。</p>
<p>此外，如果你一开始不相信人这辈子活着有什么目的，你也可以写下“1. 活着不为了什么。” 没关系，只要你愿意坚持想和坚持写下去，你也会找到让你哭出来的答案。</p>
<p>作为你的参考，Steve Pavlina在做这个练习的时候，花了25分钟在第106步找到了他的最终答案。而那些让他有一阵情感涌动的答案分别出现在在第17，39，53步。他将这些抽出这些答案重新排列，最后在第100步到第106步答案得到了升华。想要放弃的感觉出现在第55到60步（想站起来做点其他事情，感觉极度没有耐心等等）。写到第80步的时候，他休息了2分钟，闭上眼，放松大脑，然后重新整理自己的思绪。这么做很有效果，在那2分钟的休息后，他的思路和答案变得更加清楚。</p>
<p>如果你一定要拿笔者来做参考，那么答案是我当时比较无知，还不知道这个系统的方法，所以我用了四个月的摸索和迷茫，撞了很多墙，才找到了最终的答案（在第二章个人故事里会提到）。但经过笔者核实，这个方法科学有效，只因为它提炼出了关键的原理。</p>
<p>无论你愿意用什么方法，你最终的答案一定会是一句比较长的句子，或者几句句子的组合。这个答案在外人看来一定非常的空洞，就像是我前面所说的那种“谁都知道，但是只有少数人真正理解的大道理”。但是这几句空洞的句子会对你有非常丰富而且有意义的含义–因为这是你自己用了至少一个小时的时间和精力去整理你过去所有的经历，去思考，去判断，去剔除，去整合，去沉淀，最终领悟出来的。如果你认真看完了从文章开始到这里为止所有的分析，你就会理解为什么这个方法是非常有效的。</p>
<p><strong>关于为什么要有个人生目标（以及它和活捉林志玲的关系）</strong></p>
<p>这是个好问题。所有人的终极目标其实都一样，就是用有限的人生货币去换最多的幸福感（这个幸福感可以来自内在的、外在的、和世界上任何人和物）。但大部分人都觉得这是件很困难、而且不知道如何下手的事。最大的问题其实就是，如何最大化人生幸福感是一个几万行的方程式，当中你要做出数亿个选择，而我们却指望用逻辑去解决它。</p>
<p>你也知道，逻辑是多么不靠铺的一个东西。很多时候，你往往觉得你已经把脑子想炸了，但还是做不出一个选择，这是大脑逻辑功能达到处理极限的问题，它只能解决绕五个弯的问题，面对绕一百个弯的问题它弱得和奔2一样；又有的时候，你的逻辑很容易被你的欲望给废掉了，这个情况最常出现在早上起床的时候–“我该起床么？”“Hmmm…睡着挺舒服的，不起了。”–你以为你用逻辑完美地解决了问题，其实你只是让欲望解决了问题，然后用逻辑完美地说服了自己。所以我们经常在过了一段时间后，突然发现，我们的欲望挂着“逻辑”的羊头“解决”了所有问题，但是自己却空虚得没有任何幸福感。我们不想这样，所以我们需要把你的大脑处理每一个选择的过程变得非常简单正确。</p>
<p>确立一个人生目标为什么可以解决这个问题？很简单，人生目标把你那个不知道是什么火星进制的大脑逻辑简化成了二进制。假设你的人生目标是“活捉林志玲”（当然，这只是一个不可能发生的例子，千万不要有人因为写到这个目标哭了出来），那么你每天早上的起床的时候的过程就是：“我该起床么？”“Hmmm…继续睡下去能帮助我活捉林志玲么？”“很明显不能。起床！”</p>
<p>这就是你听过很多励志演讲者会说：“究竟是什么让那些幸福快乐的人每天一大早醒来想也不想得就冲下床去做他们要做的事情？”–是林志玲。噢不，是他们的人生目标。其他事情也一样：“我要吃饭么？”“不吃饭我能活捉林志玲么？””不能，所以我要吃饭。”“我要去夜店么？”“去夜店能帮我活捉林志玲么？”“不能，锻炼好身体一定可以。所以我还是用去夜店的时间货币去换强健的体格和咏春拳吧。”你会发现你不用再去依赖不靠谱的复杂逻辑，做任何决定都很简单而且正确。当然，你的人生目标会“活捉林志玲”看上去高尚、空洞很多，它也一定会涵括你对自己、对身边亲人好友、对世界的考量。但记住无论如何，你那外人看似空洞的目标曾让你哭出来，所以它对你来说一定有极为丰富的含义。</p>
<p>最后，你可能会问：“我怎么能确定一直按照人生目标做出选择，我一定能最大化幸福感呢？” （其实这个问题看上去不怎么需要解释的）那是因为你的人生目标是你自己剔除了你欲望带来的杂七杂八的“伪装的需求”，经过沉淀以后得出的你内心最深处最想要的东西，它是你真正的需求。跟随着它你会在短期获得应该获得的快感，更会在长期得到你需要的幸福感。</p>
<p><strong>关于现实和人生目标</strong></p>
<p>我想给所有已经、即将、或者希望找到人生理想的人，和大家分享两个很平凡的故事，作为结束。</p>
<p>我想讲的第一个故事来自我大学最重要的两个导师之一。他是沃顿的一个明星教授，麻省理工本科，哈佛法学院毕业，五十多岁，教了十七年谈判学的课程。尽管他的课作业量很大，但每一年他的课都已几乎满分的学生评分位列沃顿所有课程的前三甲。</p>
<p>在我大学毕业前，我约他在费城附近的一个小镇吃了顿午饭。他跟我讲他年轻时候的故事的时候，我问他，他这辈子做出过得最让他后悔的决定是什么？</p>
<p>他说，他从小一直很想当老师，特别是小学老师。当他二十多岁从麻省理工毕业的时候，他有一个很好的机会，去家里附近的一家他很喜欢的小学做老师。但即使在美国，小学老师也几乎是待遇很低、不受尊重的一个职业。而同时，他拿到了哈佛法学院的Offer。最后他去了哈佛法学院,而这就是他这辈子做出过最让他后悔的决定。他后悔，不仅仅因为他后来发现哈佛法学院是那么的无聊而且勾心斗角，更因为他当时为了一个被社会所尊重、所仰慕的选择，放弃了一个被社会遗弃、看不起的选择。</p>
<p>他说他很幸运，一直那么喜欢当老师，在从法学院毕业许多年的颠沛流离以后，终于如愿以偿成为了一个老师。当我和一些人说起这个故事的时候，他们的第一反应就是，这不是乱说么？如果不是去了哈佛，他可能现在还只是个小学老师，根本不可能成为沃顿教授啊。我想，现实和理想的意义对于每一个人都是不同的，我们只需要理解并不是所有人都觉得成为成为名校的教授是比普通学校的小学老师更伟大、更幸福的成就。</p>
<p>第二个故事开头，我想问一个问题：你有没有考虑过我们每天上校内上微薄，看到很多人分享各种励志、免俗、追求梦想的文章，但他们最后究竟做什么去了？你可能以为他们马上回归现实去了。但其实他们很多时候，是怀揣着那些道理，继续去做他们知道怎么做的事情。这就有了第二个故事。</p>
<p>每一个二十岁左右的年轻人都像一台高速运行的电脑。一代比一代运转地更快。我们从懂事开始就有别人告诉我们要运行各种程序，上幼儿园，上小学，上初中，上高中，上大学，工作，等等等。我们停不下来。关键是，我们很难运行自己想要运行的程序，因为过去二十年里面我们运行的所有程序都是别人编好以给我们的–我们自己不会编程序。</p>
<p>如果有一天，有一台电脑突然下了决心，要运行自己的程序，他就必须先停下来。这时，他会看着周围所有的电脑依然在高速运行着，甚至嘲笑他怎么不动了，然后把他远远地甩在后面。而他，需要慢慢地开始学习自己编程，这个过程很漫长，很痛苦，因为从来没有人教过他。这就是为什么世界上只有少数人在运行自己的程序。</p>
<p>说这两个故事不是为了励志，而只是为了告诉大家如果今天或者明天你找到了人生目标，将会发生一些什么：一、即使你内心已经明确地知道你想要什么，依然会有一些更为社会认同的东西来诱惑你，要永远记得坚持。二、如果你坚持了，你一定会经历一个学习自己写程序的过程，这个过程会是痛苦并漫长的。总有一天我们会愿意去面对这个过程。好消息是，我们都还年轻。所以不如趁着现在还有那些热情和勇气，去撞一撞那些墙，用最少的代价。</p>
<h3 id="第三部：过去一年里的个人故事，给所有十年来认识的、和喜欢听故事的朋友们"><a href="#第三部：过去一年里的个人故事，给所有十年来认识的、和喜欢听故事的朋友们" class="headerlink" title="第三部：过去一年里的个人故事，给所有十年来认识的、和喜欢听故事的朋友们"></a>第三部：过去一年里的个人故事，给所有十年来认识的、和喜欢听故事的朋友们</h3><p><strong>辞职前的故事</strong></p>
<p>我从去年暑假结束，拿到回黑石的offer后，就开始了寻找自己人生目标的旅程。2010年的9月到12月，我过得挺糟糕的。因为我每天起来都在想我接下来这辈子要干什么。我可以很清楚地看到如果我接受了那个offer，我未来两年的前景。我们办公室里有一个韩国人Jay，我实习的时候是他做分析师的第三年。每年的反馈中，他都是黑石他那一届全球所有分析师里最强的那一个。我没有怀疑自己能够成为这届最好的分析师，但同时，我也可以很清楚地看到，J是我能成为的极限。但仔细想想，J也不过只是那样，像永动机一样地在办公室努力工作，像尊贵的孩子一样在夜店潇洒地玩耍。J是最出色的，但也是黑石所能创造的最出色的。</p>
<p>后来我想到了环境的局限性，想到了密集网络。我在上中的时候，我这届最好的学生去了北大和清华。而在沃顿时，最好的学生去了高盛直投、贝恩资本、凯雷、KKR、Jane Street等买方。我想到我们是不是已经成为模式化思维的牺牲品（victims of stereotypes)。 我们的社交圈里都是与我们同类的人，我们互相交流、竞争、鼓励、启发，处于所谓的密集网络。我们自以为我们充分见识了整个世界，但其实我们只是在重复肯定同一类信息。所以如果你是“最出色的”那一个，那么你极有可能就是所有和你同类的人当中最出色那一个。但这也就是你的极限。</p>
<p>而有另外一群人，他们只是想和别人有点不一样，他们想去外面看看，去见识见识这个世界究竟有多大，他们想要找到自己独特的生活。对于这些人来说，天空才是极限。说实在的，所有当年选择DIY出国的朋友们，如果今天你有幸拿到了让那些当年去北大、清华的那些同学羡慕的Offer（再次向躺着也中枪的北大、清华同学致以崇高的歉意），如果你有了比同龄人更多的见识，那绝对不一定是 因为你比他们更出色，很大程度上是因为在那个出国还没有像今天一样流行的年代，你没有被那个上北大、上清华的模式化思维所套住。所以老天很弄人，因为所有一直在追求“出色”和“卓越”的人最后都在他们最坚信的标准上“输”给了那些只是想过自己独特生活的人。</p>
<p>当然，2010年末的时候，我只是确定了自己是被老天玩弄的人哪。但幸好我还有一年时间，我决定一定要要找到一个属于自己的生活目标，然后坚定地走下去。一开始，我和很多人一样，觉得人生的终极目标就是要多走走，去见识这个世界，活出自我。但后来我发现这个目标其实只是说着好听，但是其实不能给人带来持续的动力，然后我就很伤心。再然后，我好不容易想出了一个有点与众不同的目标，就是“做个有意思的人”（Be an interesting person）。因为对我来说，这是我当时能给另一个人的最高评价。但后来我又想了想，这个目标用管理学的标准来说，就是太不具体太不精确所以很难提供持续动力。然后我就更伤心了。所以从九月到十二月的四个月里，每天起来就因为找不到人生目标而痛苦。因为自己跟自己的内心对话太多，经常一不小心就错乱了。当时也没有人告诉我什么20分钟就可以找到人生目标的这种好事。于是我就上了很多奇奇怪怪的课，和各种奇奇怪怪的人交流，希望从他们的经历中获得一些启发。那段时间我过得真的很彷徨也很烦躁，好在我坚持了下来。我谈判课上的教授成为了我很重要的一个导师–尽管他从来没有一对一给予我任何指导。但就像我前面提到的，那些改变我们人生的道理，都不会是别人教会的。进入到十二月以后，我的目标慢慢找到了我。</p>
<p>四个月里经过无数内心挣扎之后沉淀下来的思想最终被我总结成了两句很简单、看似和“做个有意思的人”一样不具体、但对我而言包含了丰富含义的话：</p>
<p><strong>“To grow and to help others grow. To live and to help others live.”</strong></p>
<p><strong>“成长，并帮助别人成长。体验和经历生活，并帮助别人体验和经历生活。”</strong></p>
<p>这两句话就成了我的人生目标。它能让我感动得哭，也能让我感动得笑。最重要的是，尽管这两句话在外人看来可能莫名其妙，但我发现这两句话解释了过去二十多年里自己做的许多事情背后的原因，其中包括了我为什么从小一直都不好好读书，为什么选择出国，为什么一直逃课，为什么在2009年和一群朋友一起创建了BIMP这样一个神奇的项目，等等等等。</p>
<p><strong>关于辞职的决定</strong></p>
<p>在确定了人生目标以后，我的思路和视野都变得清晰了很多。我很快找到了我想要做的事。和身边许多的朋友一样，创业也曾经是我大脑中的考虑过的一个想法。但我一直想不到任何我愿意用我几乎所有的时间货币去换的一个创业项目。但在确定了人生目标的今年一月份，我几乎没有花什么时间就确定了一个项目的大方向，这个商业项目的创意像是奔着我而来的。然后再通过不断的完善从一个不成熟的产品渐渐变成一个成熟的产品，一个真正可以持久给所有人带来价值的产品。</p>
<p>所以，可能和许多我很尊敬的朋友不同，我的出发点并不是“慈善”和“义务服务”，“创业”也从来都不是我的目标（一个学了四年金融的人怎么可能一直心存“创业”这个目标呢），我的目标就是实现“成长，并帮助别人成长。体验和经历生活，并帮助别人体验和经历生活。” 简单的说，我的内心并没有一个声音告诉我“你一定要创业、你一定要创业”，只是碰巧创造一个商业化的项目是实现这个目标最好的方式，而创立一个商业项目这件事碰巧叫做创业。</p>
<p>而另一方面，在黑石工作可以帮助我“成长”和“经历”，但是我觉得在黑石的一个暑假实习里，我用20%的时间经历了接下来的两年里可能会经历的80%的体验，对我来说已经很值得了。我也一定会“成长”，但是未必会比创业成长得更快、更深刻、更理想、更多样化（比如说我就没有办法做我一直很想做的美工设计工作了！）。最重要的是，我意识到在黑石我基本上不能实现我人生目标的另外50%–“帮助别人成长。帮助别人体验和经历生活”。所以结果就是，“是否辞去毕业后的第一份工作，直接成为无业游民”这么重大的一个选择，被我用人生目标给瞬间解决了。有多瞬间呢？我后来发现了个有趣的巧合。</p>
<p>四年前，我曾经尝试着去写一篇回忆录，来回忆出国两年多的旅程，然后这篇回忆录不幸地才写到出国的第一年就没有后来了。尽管写回忆录是一件有点折磨人的事情，但读回忆录绝对是件超开心的事。当中我写到过六年前我决定放弃轻松进北大清华的机会，毅然决定出国念高中，因为上海中学不支持孩子们申请国外大学。原文如下：</p>
<p>“北大清华这种学校我肯定不去!”我当时的有两个很简单也很清晰的想法：一，I deserve the best in the world，二，也是更重要的想法，我想，就算最终在美国毁了，我至少做了一个帅到五体投地的决定，我鄙视了北大清华。更离奇的是，从那以后的两年至今，我几乎从来没有为这个决定后悔过，也不觉得这有什么好想的。仿佛这道选择题是在侮辱我的智商而不是测试我的智商一样。无论如何，两年后的现在，我相信，这个帅到五体投地的决定，是我一生至今最正确的决定。”</p>
<p>这个故事告诉我们：人是不会变的。把上文中的北大清华换成黑石，就是我的大脑在半秒中以内做出辞职这个决定的思考流程。可见大脑在考虑一些人生大事上是不怎么需要运作的，让心去运作就足够了，而你的人生目标就是你的心。</p>
<p>如果说这六年里，相比上面这段话我又多了什么领悟，那就是（1）一个人生目标（2）人生没有任何决定是错误的，因为你永远无法知道另外一个选择是否是正确的。</p>
<p><strong>撞上的许多堵墙</strong></p>
<p>Randy Pausch在他著名的“最后的演讲”中提到过一个很实在的观点。他说，在我们追寻理想的道路上，我们一定会撞上很多墙，但是这些墙不是为了阻挡我们，它们只是为了阻挡那些没有那么渴望理想的人们。这些墙是为了给我们一个机会，去证明我们究竟有多想要得到那些东西。</p>
<p>我撞上的第一堵墙，就是我没有如我所愿地一毕业就辞职。考虑到团队开发的进度，个人诚信问题方面带来的压力，家庭的压力，以及很多直接辞职可能带来的负面因素，我最终还是回去工作了四个月才得以正式辞职，其中包括一个月的培训。很长一段时间里，大老板都不允许我告诉任何人我辞职的事情，但大老板自己却没有做好保密工作，以至于同事们最终都知道了我一个小小的分析师要辞职。但我又被规定不能公开，所以在我座位附近的办公室气氛很糟糕，上班感觉度日如年。当中还穿插了许多压力山大的故事，比如我遇上了公司最高管理层一年一度的3v1谈话，在一个阳光明媚的下午被三个在华尔街响当当的名字各种拷问，因为我光荣成为了公司历史上第一个干都没怎么干就宣布不干了的分析师（从小到大，坏孩子光荣榜上真是永远有我的名字）。又比如曾经跟我关系很好的一个VP整整四个星期把坐在整个办公室出入口的我当空气。但是无论当时多煎熬，现在想来都是非常独特的人生经历。</p>
<p>其实我很感谢和尊敬黑石，不仅因为我仍然是个热爱金融的家伙，更因为每一个我接触过的同事的做事风格都对我的个人风格产生了一定程度的影响。从情感的层面上，我最感激的是负责团队人事的韩国VP，在我辞职的过程中帮我做了许多疏通的工作。在我离开的前两天的晚上，他说了一句我印象很深的话。他说，“Denny，你知道，作为你的上司，这次我面对着一个选择，是照顾公司的利益还是你一个年轻人的利益。我选择了后者。我希望你以后不用面临这样的选择。但如果你有一天遇上了，我希望你可以跟我做一样的决定。”</p>
<p>我离开的那一天，我的同事和几个以前一起共事过的朋友给我发来了道别邮件。让我很高兴的是，他们在祝福中都用了同一句话“You are very brave”（“你很勇敢”）。之所以高兴，是因为无论今后的道路如何艰难，至少在旅程的起点我实现了奥巴马用来形容乔布斯一生的第一个形容词。对于一个活在当下的傻子来说，这已经足够了。</p>
<p>现在我在上海的家中，和我非常喜欢而且非常有创造力的人们一起工作。虽说生活条件很普通（以银行家的标准来说的话简直是糟糕透了），虽说工作强度和时间依然和在黑石的时候差不多（以银行家的标准来看的话处于中上水平），但回到上海后的这段日子确确实实是我人生中自我学习曲线上升最快的一段日子。所以顺便说一个建议，当那些备受尊敬的金融机构告诉你为什么要选择他们的时候，特别是关于学习曲线的那些理由，不要那么快就为之屈服。他们不仅有可能（虽然也仅仅是可能）在推销给你一些你并不需要的东西，并且他们永远不会带你看清楚这个世界上全部的可能性。你要跳出“密集网络”，自己去看清楚。这个建议出自依然热爱金融的笔者。</p>
<p>我一年的故事就这么讲完了。如果回顾总结过去一年的人生，那么最好的形容就是从一年前我确定了人生目标的那天起，一切就开始失控。但我想在这个回顾的最后，和所有已经确定了自己人生前进方向的朋友，分享这一年最大的感想：你的理想就像一辆车，如果你觉得这辆车的一切都在你的控制之中，那么可能说明你开得还不够快 (Your dream is like your car. If you are in full control of it, you are not driving it fast enough)。</p>
<p><strong>关于感谢</strong></p>
<p><code>感谢所有支持你、欣赏你、否定你、看低你的人。</code></p>
<p>我一直说，永远不要忘记你从哪里来，要到哪里去。我不是一出生就上了好到可以改变我的学校，一直到六年前，我都不算是个好学生，学生生涯当过的最高的职位是小队长，期中期末考试好像从来没有进过班级前三，有一年甚至还是全校倒数10%，更不知道自己要什么。感谢自己不知为什么突然一根筋地开始愿意好好努力，自从那以后就知道实现梦想就靠坚持付出，没有别的秘诀。后来我出国，看到了一个很大很大的世界，在一路的坚持中，遇上了许许多多带给我灵感的人，他们用他们的经历影响和改变了我。这就是为什么我一直告诉自己不要忘记你从哪里来，这也是为什么我想继续传播我受到的影响，可能是作为一种感谢。</p>
<p>今年上半年还在上创业课的时候，我一边要照顾自己的项目的开发，另一边又创业课项目团队中的其他四个成员眼看即将毕业，完全不作任何事情。我的教授Gelburd，一个前创业家，也是我在沃顿的第二个导师，他并没有因为我一个人担纲整个项目的开发和准备而减轻对我们团队的项目的要求，但是他给了我很多鼓励。期末演示日的那天，我在一天有三个期末演讲的情况下，被迫一个人完成了80%的项目演示。没有什么奇迹，我们的质量肯定不是最好的。但在我毕业的前几天，我收到了这门课的成绩。Gelburd给了我A+。他写了一封感谢信给他，他回复我说，每一年上这个课的学生中，真正去创业的不出三个，I think you will be come very successful。</p>
<p>收到他的邮件，我告诉我自己，绝对不能辜负曾经看好你的人。哪怕只有一个看好你的人，为了那一个人，你都必须要坚持下去。</p>
<p>同样地，过去的许多年里，我被许许多多人否定过，甚至包括身边很好的朋友。从五年前的：“就你也想进沃顿？”一直到几年的：“你还是别创业了吧”，“你肯定不会辞职的”等等。这些否定和质疑一路上给我很大的鼓舞，让我很清楚的知道什么是我真正想要的。</p>
<p>过去的这六年，我最大的幸运就是遇到了许许多多强大的人，他们强大的地方可能是一些人生经验，可能是一个很偏门的技巧，有或者是一个很奇怪的逻辑，一个坚持了几十载的生活细节。今后我会一一道来。</p>
<p>以上故事，分享给所有相信人生就是不断经历的朋友们。<code>明年，我们依然年轻。</code></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/06/《浪潮之巅》四大定律/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tming">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="tming's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/06/《浪潮之巅》四大定律/" itemprop="url">《浪潮之巅》四大定律</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-06T19:06:12+08:00">
                2018-01-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>《浪潮之巅》是吴军系列的第二本书。在这本书里用了一个更加宏观的视角去俯视了整个IT行业的发展史，给大家列出了4条互联网行业的一些最基本的定律。核心观点：<strong>摩尔定律，安迪-比尔定律，诺维格定律，还有基因决定定律。</strong></p>
</blockquote>
<h3 id="一，摩尔定律"><a href="#一，摩尔定律" class="headerlink" title="一，摩尔定律"></a>一，摩尔定律</h3><p>差不多是每18个月，就是每1年半，IT产品的性能就会翻一番，价格则会降一半，这个就是摩尔定律。BTW，摩尔定律里说的产品性能主要指3个方面，一方面是计算机的运算速度，另一方面是计算机的内存，还有就是上网的速度。</p>
<blockquote>
<ol>
<li>案例1：<br>07年的时候，世界上最快的计算机是IBM出的蓝色基因，它的速度是每秒钟365万亿次运算，到10年，我们国家的天河1A计算机计算速度每秒高达2570万亿次。到12年，IBM的红杉计算机速度是1.6亿亿次。</li>
<li>案例2:<br>苹果一代的存储容量只能存一个文档，现在一个手机的存储容量就是200多G。</li>
<li>案例3:<br>1994年的时候上网下载速度是每秒2.4KB，下载一个谷歌输入法得8个小时。</li>
</ol>
</blockquote>
<p>这种高速的增长就让互联网公司有几个特点：</p>
<ol>
<li>为了不断提升芯片的性能，IT公司必须在很短的时间内，投入大量资金完成下一次产品的开发。</li>
<li>有了这些硬件的支持，软件方面就有了发挥的空间。就比如，2000年以前，不会有人想去办一家YouTube这样的网站，因为首先网速就跟不上。<br>案例：</li>
<li>最后，摩尔定律让公司的研发必须针对多年以后的市场。在Google内部，每一次基础架构的升级，都要按照目前计算和存储能力的10倍来设计。</li>
</ol>
<h3 id="二，安迪-比尔定律"><a href="#二，安迪-比尔定律" class="headerlink" title="二，安迪-比尔定律"></a>二，安迪-比尔定律</h3><p>“比尔要拿走安迪所给的”。安迪是英特尔公司CEO安迪.格鲁夫，比尔就是比尔.盖茨了。安迪-比尔定律把本来属于耐用消费品的硬件设备变成了消耗型商品，一直在刺激整个IT产业的增长。</p>
<blockquote>
<p>比如：你现在嫌苹果7太贵，想的等过上2年，等苹果9出来的时候再来买苹果7，那按照摩尔定律，它的价格会降一半，如果这样人们是没有动力去换手机的，但手机和计算机每年的销量都会稳定增长。因为软件会吃掉硬件性能，苹果9出来再去买苹果7，那时候很多软件在苹果7上就压根运行不了。</p>
</blockquote>
<p>但是整个IT生态链是以微软为首的软件开发商吃掉硬件带来的全部好处，迫使用户更换机器，让惠普，戴尔这些制造硬件的公司收益，这些公司再向英特尔这样的半导体公司订购新的芯片，同时再向外设厂商购买新的外设，在这中间，各家的利润先后得到了相应的提升，股票也随着增长，各个硬件厂商赚到钱后重新投入进行研发。如果硬件更新不了了，软件的复杂性也就有了一个终极限制。到时候一定会有新技术突破整个瓶颈。</p>
<p><em>摩尔定律和安迪-比尔定律是从产业的角度看的，科技公司的发展要遵循诺维格定律和基因定律。</em></p>
<h3 id="三，诺维格定律"><a href="#三，诺维格定律" class="headerlink" title="三，诺维格定律"></a>三，诺维格定律</h3><p>诺维格定律，当一家公司在某个领域的市场占有率超过百分之50后，将无法再使市场占有率翻翻，就必须寻找新的市场。诺维格是Google研究院的主任。它包含2层意思：</p>
<p>一家公司的市场份额总是有限的。</p>
<blockquote>
<p>比如，朗讯想在萎缩的交换机市场上实现高速增长，把设备卖给那些根本还不上钱的公司，但实际上并没有进账。再比如，花旗银行为了达到高速增长，把钱贷款给那些根本还不上的客户，最后导致数千亿美元的坏账。但不扩张就得死，一是反摩尔定律在起作用，还有一个原因就是，一家公司必须不断的满足大众的增长预期，他的股票才能保证不下跌。换句话说，一个IT公司如果今天和18个月前卖掉同样多的，同样的产品，它的营业额就会下降一半。通俗来说，一个姑娘一定得觉的小伙有上进心，肯持续努力，虽然现在没啥钱，但是一个好的预期就够了，相反，就算现在小伙很富有，但是天天去赌场混，那给姑娘的预期就会很差。</p>
</blockquote>
<p>一家公司永远不会有稳定的时候，永远得不断的寻找新的增长点。</p>
<blockquote>
<p>怎么找到新的增长点，一个是横向扩展，另一种是转型。横向扩展，就是一家公司把现有的技术和商业优势，用到相关的市场上去。可以最大限度的利用公司原来的优势和经验，在新的领域很快站住脚。Google从基于搜索的广告扩张到基于内容的广告，微软从个人电脑操作系统 扩展到应用软件，惠普从小型机扩展到个人电脑，迪士尼从动画片扩展到传统电影。</p>
</blockquote>
<p><em>转型说起来容易，做起来特别难，那是因为还有基因定律存在。</em></p>
<h3 id="四，基因定律"><a href="#四，基因定律" class="headerlink" title="四，基因定律"></a>四，基因定律</h3><p>基因定律，就是说一家在某一个领域特别成功的公司，当开拓新领域时，会不自觉的用原来的做事方法，思维方式去应对新市场。新的领域是年轻公司唯一的机会，自然会全力以赴。而成熟的公司一旦新业务和传统业务有冲突，通常的策略是牺牲新业务，让转型又多了一个隐形的障碍。比如说，苹果从个人电脑到iPhone，再到iPad，看起来是成功转型了，但其实它的基因并没有变，还是一个相对封闭的系统，苹果的基因就决定了它必须靠硬件来赚软件的钱。</p>
<h3 id="五，总结"><a href="#五，总结" class="headerlink" title="五，总结"></a>五，总结</h3><p>这本书给我们讲解了很多IT公司的兴衰成败史，我们从中可以发现4条定律，分别是摩尔定律，电子器件的性能每18个月就会翻一倍，安迪-比尔定律，软件会不断的吃掉硬件的性能，诺维格定律，一家公司的市场份额是有限的，它必须不断的扩张来满足所有人的预期，基因决定定律，公司的基因是限制一家公司转型和发展的源头。</p>
<h3 id="六，金句"><a href="#六，金句" class="headerlink" title="六，金句"></a>六，金句</h3><ol>
<li>人类的文明和技术是不断进步的，旧的不去，新的不来，只有清除掉阻碍我们发展的那些庞大的恐龙，才能为人类提供新的发展空间，从这个角度讲，一个昔日的跨国公司的衰亡。也许是它为这个社会做的最后一次贡献。</li>
<li>华尔街的贪婪既会捧起，也会扼杀一个科技新星。</li>
<li>Google是个奇怪的地方，也许是因为年轻人太多，他们不懂得传统也不拘泥于传统，只要认准了公司对社会有用，就大胆去干了。</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/11/14/RecyclerView点击项目滑动到中央/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tming">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="tming's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/14/RecyclerView点击项目滑动到中央/" itemprop="url">RecyclerView定位，点击项自动滑动到中央</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-14T19:06:12+08:00">
                2017-11-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>这几天在做项目的时候，做这样一个需求：在新闻应用中，顶部的各个tab可以切换不同标签的新闻内容，需要tab切换的时候当前tag要在在屏幕中间，也就是点击item自动滑动到中央。</p>
</blockquote>
<p>这里其实很简单，只需要自定义下决定滑动位置的方法就好了。这个方法在RecyclerView.SmoothScroller类中。我们只需要继承LinearLayoutManager就好。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">public class CenterLayoutManager extends LinearLayoutManager &#123;</div><div class="line"></div><div class="line">    public CenterLayoutManager(Context context) &#123;</div><div class="line">        super(context);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public CenterLayoutManager(Context context, int orientation, boolean reverseLayout) &#123;</div><div class="line">        super(context, orientation, reverseLayout);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public CenterLayoutManager(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes) &#123;</div><div class="line">        super(context, attrs, defStyleAttr, defStyleRes);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void smoothScrollToPosition(RecyclerView recyclerView, RecyclerView.State state, int position) &#123;</div><div class="line">        RecyclerView.SmoothScroller smoothScroller = new CenterSmoothScroller(recyclerView.getContext());</div><div class="line">        smoothScroller.setTargetPosition(position);</div><div class="line">        startSmoothScroll(smoothScroller);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private static class CenterSmoothScroller extends LinearSmoothScroller &#123;</div><div class="line"></div><div class="line">        CenterSmoothScroller(Context context) &#123;</div><div class="line">            super(context);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public int calculateDtToFit(int viewStart, int viewEnd, int boxStart, int boxEnd, int snapPreference) &#123;</div><div class="line">            return (boxStart + (boxEnd - boxStart) / 2) - (viewStart + (viewEnd - viewStart) / 2);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后就是使用了，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">LinearLayoutManager layoutManager = new CenterScrollLayoutManager(mContext) &#123;</div><div class="line">            @Override</div><div class="line">            public void onLayoutChildren(RecyclerView.Recycler recycler, RecyclerView.State state) &#123;</div><div class="line">                super.onLayoutChildren(recycler, state);</div><div class="line">                    recyclerView.smoothScrollToPosition(mCurrentPosition);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">recyclerView.setLayoutManager(layoutManager);</div></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/29/ClassLoader/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tming">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="tming's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/29/ClassLoader/" itemprop="url">ClassLoader</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-29T16:06:12+08:00">
                2017-10-29
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>众所周知的是，ClassLoader负责将Class加载到JVM中。除此之外还有审查每个类应该由谁来加载的功能，最后是将Class字节码重新解析成JVM统一要求的对象格式。</p>
</blockquote>
<hr>
<h3 id="ClassLoader的等级加载制度"><a href="#ClassLoader的等级加载制度" class="headerlink" title="ClassLoader的等级加载制度"></a>ClassLoader的等级加载制度</h3><ol>
<li>先判断自己是否加载过，如果加载过就会拒绝服务，如果没有接待过就会向上询问是否被更高一级接待过</li>
<li>上级会根据自己的接待原则检查这个会员是否被接待过，如果接待过就会拒绝再次接待，同时将已经接待过的结果反馈给下一级；如果没有接待过的话就会再向更高一级的询问.更高一级也是同样的处理办法。直到有一级接待或者告诉下一级这个会员不是自己接待。</li>
</ol>
<h3 id="三种ClassLoader"><a href="#三种ClassLoader" class="headerlink" title="三种ClassLoader"></a>三种ClassLoader</h3><ul>
<li><strong>Bootstrap ClassLoader 启动类加载器</strong> :这个加载器就是为接待室自己本身服务的。他是JVM系统控制的，仅仅是系统类的加载工具而已</li>
<li><strong>ExtClassLoader 标准扩展类加载器</strong> :是JVM本身的一部分，可是又不是JVM亲自实现的，也和普通的外部会员不同</li>
<li><strong>AppClassLoader 系统类加载器</strong> :专门为会员服务的</li>
</ul>
<h3 id="JVM加载class文件到内存中的方式"><a href="#JVM加载class文件到内存中的方式" class="headerlink" title="JVM加载class文件到内存中的方式"></a>JVM加载class文件到内存中的方式</h3><ul>
<li><strong>隐式加载</strong>：不通过代码里调用而是通过JVM来自动加载需要的类到内存的方式。例如继承某个类的时候，JVM会解析当前这个类时发现引用的类 不在内存中就会自动的将这些类加载到内存中。</li>
<li><strong>显示加载</strong>：在代码中通过调用ClassLoader类来加载一个类的方式。<br><code>this.getClass.getClassLoader.loadClass().Class.forName();</code></li>
</ul>
<h3 id="如何加载class文件"><a href="#如何加载class文件" class="headerlink" title="如何加载class文件"></a>如何加载class文件</h3><ol>
<li><strong>加载</strong>：实现抽象类ClassLoader中的findClass方法去找到.class文件并把这个文件包含的字节码加载到内存中，再调用defineClass方法来创建类对象</li>
<li><strong>验证</strong>：字节码验证，确保符合JVM规范</li>
<li><strong>准备</strong>：准备代表每个类中定义的字段，方法和实现接口所必需的数据结构</li>
<li><strong>解析</strong>：类装入器就会装入所引用的其他所有类</li>
<li><strong>初始化</strong>：类中的静态属性和初始化赋值以及静态块的执行</li>
</ol>
<h3 id="JVM的作用"><a href="#JVM的作用" class="headerlink" title="JVM的作用"></a>JVM的作用</h3><p>JVM能够跨计算机体系结构执行java字节码主要是由于JVM屏蔽了与各个计算机平台xiang关的软件或者硬件之间的差异，使得与平台相关的耦合统一有JVM提供者来实现。</p>
<h3 id="指令集与汇编语言"><a href="#指令集与汇编语言" class="headerlink" title="指令集与汇编语言"></a>指令集与汇编语言</h3><p>指令集就是可以直接被机器识别的机器码，也就是它必须是以二进制格式存在与计算机中的，而汇编语言是能够被人识别的指令，汇编语言就是为了能让人能够更容易地记住机器指令而使用的助记符。</p>
<h3 id="JVM与实体机有什么不同"><a href="#JVM与实体机有什么不同" class="headerlink" title="JVM与实体机有什么不同"></a>JVM与实体机有什么不同</h3><ul>
<li><strong>一个抽象规范</strong>：这个规范约束了JVM到底是什么？它的组成成分</li>
<li><strong>一个具体的实现</strong>：就是不同的厂商按照这个抽象的规范用软件在不同平台上的具体的实现</li>
<li><strong>一个运行中的实例</strong>：当运行一个Java程序的时候，它就是一个JVM实例</li>
</ul>
<h3 id="JVM体系结构详解"><a href="#JVM体系结构详解" class="headerlink" title="JVM体系结构详解"></a>JVM体系结构详解</h3><ul>
<li><strong>类加载器</strong>：在启动的时候会将class文件加载到内存中</li>
<li><strong>执行引擎</strong>：相当于CPU，负责执行class文件中包含的字节码指令</li>
<li><strong>内存区</strong>：模拟计算机中的存储，记录和调度模块</li>
<li><strong>本地方法区</strong>：调用C/C++实现的本地方法的代码返回结果</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/28/为什么匿名内部类参数必须是final类型/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tming">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="tming's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/28/为什么匿名内部类参数必须是final类型/" itemprop="url">为什么匿名内部类参数必须是final类型</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-28T19:06:12+08:00">
                2017-10-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>为什么匿名内部类的参数必须是final类型呢？这个在实际应用中大家可能都遇到过了，但是是否真的明白这样做的原因呢？这里就给大家做一个解释。</p>
</blockquote>
<ol>
<li>从程序设计语言的理论上来说，局部内部类(定义在方法中的内部类)由于本身就是在方法内部(可出现在形式参数定义处或者方法体处)，因而访问方法中的局部变量(形式参数或局部变量)是很自然的。</li>
<li>为什么JAVA中要加上一条限制：只能访问final型的局部变量？</li>
<li>JAVA语言的编译程序的设计者当然全实现：局部内部类能访问方法中的所有的局部变量，但是，编译技术是无法实现的或代价极高。</li>
<li>困难在何处？到底难在哪儿? 局部变量的生命周期与局部内部类的对象的生命周期的不一致性！</li>
<li>设方法f被调用，从而在它的调用栈中生成了变量i，此时产生了一个局部内部类对象inner_object，它访问了该局部变量i ，当方法f()运行结束后，局部变量i就已死亡了，不存在了。但局部内部类对象inner_object还可能，一直存在(只能没有人再引用该对象时，它才会死亡)，它不会随着方法f()运行结束死亡。这时出现了一个“荒唐”结果:局部内部类对象inner_object要访问一个已不存在的局部变量i！</li>
<li>如何才能实现？当变量是final时，通过将final局部变量”复制”一份，复制品直接作为局部内部中的数据成员。这样当局部内部类访问局部变量时，其实真正访问的是这个局部变量的”复制品”(即这个复制品就代表了那个局部变量)。因此当运行栈中的真正的局部变量死亡时，局部内部类对象仍可以访问局部变量(其实访问的是”复制品”)，给人的感觉好像是局部变量的”生命期”延长了。</li>
</ol>
<p><strong>那么，核心的问题是:怎么才能使得:访问“复制品”与访问真正的原始的局部变量，其语义效果是一样的呢?</strong></p>
<p>当变量是final时,若是基本数据类型,由于其值不变,因而:其复制品与原始的量是一样.语义效果相同.(若:不是final,就无法保证:复制品与原始变量保持一致了,因为:在方法中改的是原始变量,而局部内部类中改的是复制品)。</p>
<p>当变量是final时,若是引用类型,由于其引用值不变(即:永远指向同一个对象),因而:其复制品与原始的引用变量一样,永远指向同一个对象(由于是 final,从而保证:只能指向这个对象,再不能指向其它对象),达到:局部内部类中访问的复制品与方法代码中访问的原始对象,永远都是同一个即:语义效 果是一样的.否则:当方法中改原始变量,而局部内部类中改复制品时,就无法保证:复制品与原始变量保持一致了(因此:它们原本就应该是同一个变量.)。</p>
<p>一句话:这个规定是一种无可奈何.也说明:程序设计语言的设计是受到实现技术的限制的.这就是一例. 因为:我就看到不少人都持这种观点:设计与想法是最重要的,实现的技术是无关紧要的,只要你作出设计与规定,都能实现。</p>
<p>现在我们来看,如果我要实现一个在一个方法中匿名调用ABSClass的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public static void test(final String s)&#123;</div><div class="line">	ABSClass c = new ABSClass()&#123;</div><div class="line">		public void m()&#123;</div><div class="line">			int x = s.hashCode();</div><div class="line">			System.out.println(x);</div><div class="line">		&#125;</div><div class="line">	&#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从代码上看，在一个方法内部定义的内部类的方 法访问外部方法内局部变量或方法参数，是非常自然的事，但内部类编译的时候如何获取这个变量，因为内部类除了它的生命周期是在方法内部，其它的方面它就是 一个普通类。那么它外面的那个局部变量或方法参数怎么被内部类访问？编译器在实现时实际上是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public static void test(final String s)&#123;</div><div class="line">	class OuterClass$1 extends ABSClass&#123;</div><div class="line"></div><div class="line">	private final String s;</div><div class="line">	public OuterClass$1(String s)&#123;</div><div class="line">		this.s = s;</div><div class="line">		&#125;</div><div class="line">	public void m()&#123;</div><div class="line">		int x = s.hashCode();</div><div class="line">		System.out.println(x);</div><div class="line">		&#125;</div><div class="line">	&#125;;</div><div class="line">	ABSClass c = new OuterClass$1(s);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>即外部类的变量被作为构造方法的参数传给了内部类的私有成员.<br>假如没有final,那么:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public static void test(String s)&#123;</div><div class="line">	ABSClass c = new ABSClass()&#123;</div><div class="line">		public void m()&#123;</div><div class="line">			s = “other”;</div><div class="line">		&#125;</div><div class="line">	&#125;;</div><div class="line">	System.out.println(s);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>就会编译成:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public static void test(String s)&#123;</div><div class="line">	class OuterClass$1 extends ABSClass&#123;</div><div class="line">		private String s;</div><div class="line">		public OuterClass$1(String s)&#123;</div><div class="line">			this.s = s;</div><div class="line">		&#125;</div><div class="line">		public void m()&#123;</div><div class="line">			s = “other”;	</div><div class="line">&#125;</div><div class="line">&#125;;</div><div class="line">	ABSClass c = new OuterClass$1 (s);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>内部类的s重新指向”other”并不影响test的参数或外部定义的那个s.同理如果外部的s重新赋值内部类的s也不会跟着改变。<br>而你看到的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public static void test(String s)&#123;</div><div class="line"> 	ABSClass c = new ABSClass()&#123; </div><div class="line">		 public void m()&#123; </div><div class="line">		 	s = &quot;other&quot;; </div><div class="line">		 	&#125; </div><div class="line">		 &#125;; </div><div class="line">	System.out.println(s); </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在语法上是一个s,在内部类中被改变了,但结果打印的出来的你认为是同一的s却还是原来的”axman”,<br>你能接收这样的结果吗?<br>所以final从语法上约束了实际上两个不同变量的一致性(表现为同一变量s).</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/28/Initial Hexo/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tming">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="tming's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/28/Initial Hexo/" itemprop="url">Initial Hexo</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-28T16:54:49+08:00">
                2017-10-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.png"
                alt="tming" />
            
              <p class="site-author-name" itemprop="name">tming</p>
              <p class="site-description motion-element" itemprop="description">永远年轻，永远热泪盈眶，相信努力的意义，相信遗憾比失败更可怕。</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">9</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">tming</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  












  





  

  

  
  

  

  

  

</body>
</html>
